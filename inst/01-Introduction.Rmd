# (PART) Motivation {-}

# Introduction {#introduction}
  
## Overview

The goal of "Archaeological Science with R" is to give you a solid foundation into using R to do archaeological science. By archaeological science, I mean, systematic, objective, and empirical research into past human behaviours using material remains and traces. The goal is not to be exhaustive, but to instead focus on what I think are the critical skills for doing  archaeological science with R. Some archaeologists already use R in an _ad hoc_ way, for a quick plot here, or a linear model there. But this book will show you how R can be at the center of your entire research workflow, from when you start working with raw data until your final thesis, report, or manuscript is complete.

## Why do archaeologists need to learn to code?

This book aims to solve a specific problem. The problem is that the majority of archaeologists receive little or no training in scientific programming for data analysis and visualization, and yet they routinely analyse and visualise data. A command-line interface program such as R is ideal for this kind of work, and yet is unfamiliar and exotic to most archaeologists. A command-line interface refers to interacting with software by sending instructions to the program as lines of plain text. Instead, most archaeologists use Microsoft Excel, SPSS, or similar commercial point-and-click software. There are four problems with this. 

1. It usually results in a lot of time-consuming repetition, like copying-and-pasting between sheets in Excel, and between Excel and Microsoft Word. In recent years, biologists have seen great increases in volumes of genomic data, due to improvements in sequencing technology. This has lead them to search for more efficient ways to analyse their data, and automate their analyses. They found that spreadsheet programs did not provide enough flexibility to conduct their analyses. As a result, many have turned to R, Python, and similar programming languages to overcome the limitations and inefficiencies of Excel. The key detail here is a shift from the point-and-click interface of a spreadsheet program, to the command-line interface of a programming language where we supply instructions to the computer in plain text. 

2. It limits the development of new methods because the you are limited to what is available in the commercial software. With most commercial software packages, you are limited to the suite of functions they choose to make available to you. With an open source programming language, you and anyone else are free to implement new methods. R has extensive functions for data analysis. This includes features likes missing values and subsetting. But more importantly, R has a large set of packages (currently >6000) for quantitative analysis, visualisation, and importing and manipulating data. For most archaeologists, whatever analysis or plot you are attempting, chances are that someone has already tried it, or something very similar, and made the code available in an R package. R is also the lingua franca for researchers in statistics, who will often publish an R package to accompany their scholarly articles. This often means immediate access to the very latest statistical techniques and implementations.    

3. Commercial software also makes it difficult to demonstrate and ensure reproducibility due to the ephemeral nature of point-and-click interfaces. Point-and-click interfaces are familiar and easy to use for most people because they are very common in software programs. But it is very challenging to efficiently record a sequence of complex clicks so that another person (or you in the future) can unambiguously repeat the procedure. This means it is difficult to make your analyses reproducible if all your work is done with a mouse. It is not practical to completely abandon using a mouse when using a computer, but by using a command-line program such as R, we can record the most important steps of the analysis workflow in plain text code. Then we have an detailed record of the steps in our analysis that we can easily share with others, and re-use ourselves, months or years into the future

4. Commercial software limits transparency in research because the algorithms behind the functions are not available for convenient inspection and modification. Staticians have long noted that Excel has flawed statistical procedures [@mccullough2008accuracy, @yalta2008accuracy], and introductory texts on statistics warn students not to use Excel when the results matter [eg. @keller2000applied]. With an open source program such as R, you can easily inspect and alter the algorithms behind every operation. R in particular has the added advantage of being one of the most accurate software programs for statistical analysis [@almiron2009, @keeling2007comparative].

Using a command-line program such as R goes a long way towards solving these four problems. 

This book is complimentary to the major textbooks and handbooks of quantitative archaeology (Baxter 2003; 1994, Van Pool and Leonard 2011, Drennan 2009, Shennan 1997). These are excellent for relevant statistical theory, discussion, and examples, and this book does not replace them on your shelf. However, those books have three limitations that we will address in the following chapters.

1. First is the absence of 'plug-and-play' examples, leading the reader to invest substantial effort to implement a method described using formulae, creating many opportunities for error. Van Pool and Leonard 2011 instruct their reader to do their statistical analyses by hand, an impractical and outmoded recommendation when computers are readily available. The amount of effort required by these texts is prohibitive to rapid exploration and experimentation of data using new methods. This book includes reproducible examples using real data sets so you can easily step-through the analysis to explore the effects of different parameters, and easily interchange your own data.    

2. The existing books give little coverage to intuitive and methodologically more robust methods such as resampling and Bayesian analyses, favoring traditional parametric methods. This reflects a time when computational power was scarce, and computations often done by hand or with a calculator (cf Fletcher and Lock 1991). Modern computers can now easily handle resampling and Bayesian methods, and R is unique in having a mature set of methods for computing common tests in these frameworks. These methods are also increasingly common in the published research literature. This book introduces these alternative approaches to give you more options in your analytical toolkit.    

3. The currently available books are silent on the practical mechanics of many common data analysis and visualization tasks in archaeology that are not traditionally considered statistics. This includes displaying and analyzing stratigraphic information from excavation and spatial data from surveys. Learning a tool-chain for these tasks is traditionally done on your own, and often at substantial expense with proprietary software. This book demonstrates how to write simple programs that are especially useful for archaeologists. By doing this, and providing code for other common tasks, this book addresses the need for instruction in a comprehensive open source tool-chain for these common tasks in archaeological science. It does this by presenting a reproducible research environment to show how R and its contributed packages can be used for start-to-finish research into survey, excavation, and laboratory data. 

My hope is that a practical and accessible introduction to reproducible research, such as this book aims to provide, will improve openness and transparency in archaeology generally. It will contribute towards creating a community of researchers where it it normal and routine to publish code and data (after appropriate precautions are taken to protect sensitive information) with reports and publications, so that we can engage more deeply with, and learn more efficiently from, each other. 

This is not a book of detailed discussions of statistical theory, and you will be referred to other texts on technical details of algorithms, etc. This is a book introducing R for practical and efficient implementations of common tasks in archaeological science, and serves as a springboard to more advanced R programming. The specific topics covered in this book are: 

* Implementing reproducible research with literate programming as a practice that is good for science generally, and good for your individual productivity 

* Working with common archaeological data structures, ingesting them into R and manipulating them from messy formats to tidy formats ready for analysis

* Visualising spatial data by making maps, doing spatial analysis and site classification 

* Visualising and analysing stratigraphic data from archaeological excavation

* Working with relative and absolute chronologies by doing seriation, and calibrating, analysing and visualising radiocarbon dates 

* Working with data from stone artefacts, faunal remains, pottery, glass, and metal artefacts 

* Compositional analysis using cluster and principle components analyses of multivariate data 

* Simplifying collaborative research with version control 

 
## Why R?

If you are new to R, you might wonder what the appeal is, especially when there are so many programming languages in common use. Some of the characteristics that drew me to learn R include:

* It's free, open source, and available on every major type of computer. As a result, if you do your analysis in R, anyone can easily reproduce it.

* It is specialised for use with statistical analysis and data visualisation. R was originaly develped by statisticians, and continues to be widely used by professional and academic statisticians. This means that there are strong links between the statistical literature and R code. Many of its algorithms have been vetted by publication and thoroughly tested through extensive use. It is easy to go from statistical theory to practice using R. 

* An active, supportive and generally progressive community. It is easy to get help from experts on the R-help mailing list, Stack Overflow, or subject-specific mailing lists. You can also connect with other R learners via social media, and through many local user groups. I have found Stack Overflow and twitter to be particularly useful sources of information. Package authors are often pleased to see their packages used by others, and willing to answer questions about your use of their package.  

* Flexible tools for communicating your results. R packages make it easy to produce html, pdf, or Microsoft Word documents that include text, tables and figures, all generated from R code. I find this to be a huge time-saver, especially when weeks or months pass between working on a project, and I cannot remember all the details of the last work I did. When I look over my R code I can quickly recall my analysis plan and resume from where I stopped. 

## Who should read this book

This book is written for archaeologists who are keen to expand their analytical horizons and gain access to new methods and new, more efficient, ways of organising their research process.  No prior knowledge about R, computer science or programming is expected, but a curiosity about statistics would be an advantage, as well as a readiness to read beyond this book to make decisions about the suitability of statistical methods for your specific research questions. 

## Prerequisites

To run the code in this book, you will need to have R installed on your computer, as well as RStudio, an application that makes it substantially easier to use R. Although I have been interested in R for many years, it was only after RStudio was first released that R replaced Excel and SPSS for me. Both R and  RStudio are free to download and easy to install. You can install it on most recent versions of Windows, OSX (Mac) or Linux. When used together, R and RStudio will help you to have a smooth and efficient experience when programming. RStudio provides many features that greatly simplify programming with R (my favourite is tab-completion). I do not recommend using R without RStudio, especially for the beginner. 

You should download and install both R and RStudio before attempting to follow any of the examples in this book. If you have installed these programs on your computer in the distant past, you should update them now (new versions of R are released every six months). 

### R

To install R, visit [cran.r-project.org](http://cran.r-project.org). CRAN is the 'Comprehensive R Archive Network' which hosts the official releases of the R software and documentation. Then click the link that matches your operating system. What you do next will depend on your operating system. You will need to install a development environment, this is also specific to your operating system. The development environment provides some additional programs that give you access to more advanced features of the R language. 

Here's a summary of the basic steps to download and install R for the most common operating systems:

* Mac users should click the most current release. This will be the `.pkg` file at the top of the page. Once the file is downloaded, double click it to open an R installer. Follow the directions in the installer to install R. You should also install Xcode from the Mac App Store to install the development environment.  

* Windows users should click "base" and then download the most current version of R, which will be linked at the top of the page. You should also install [Rtools](http://cran.r-project.org/bin/windows/Rtools/) to install the development environment.  

* Linux users will need to select their distribution and then follow the distribution specific instructions to install R. [cran.r-project.org](https://cran.r-project.org/bin/linux/) includes these instructions along side of the files to download.

If you are not sure about these download and install steps then you should research the general methods of installing software for your operating system, which are beyond the scope of this book.

After installing R on your computer, you may be tempted to open it and start exploring. I don't recommend this because the R user interface is not intuitive for novices. Instead, read on to continue with downloading and installing RStudio. Then start your explorations in RStudio, which has a more user-friendly interface. 

### RStudio

Once you have R installed, it is time to download RStudio. To download RStudio, visit [www.rstudio.com/download](http://www.rstudio.com/download). 

Choose the installer that matches your operating system. Then click the link to download the application. Once you have the application, installation is the same as for most programs on your computer. Once RStudio is installed, open it as you would open any other application. It should look something like this:

![insert RStudio_first_view about here]

When you start RStudio for the first time, you'll see your screen divided into three or four window panes. If you don't see four window panes similar to the image above, go to File -> New File -> R Script to show all four panes. Here is an explanation of what you see in the figure above (for more details about the RStudio interface, see the RStudio website <https://www.rstudio.com/products/rstudio>, Verzani [-@verzani2011getting], Gandrud [-@Gandrud2015], and Racine [-@racine2012rstudio],):

- The top left pane is the text editor, known as the 'source'. This is where you write and edit code and text. The text editor in RStudio is analogus to a word processor such as Microsoft Word, but has many additional convienent features for writing and editing code. The text editor does not include any tools for formatting your text _in situ_, for example you cannot make words appear in the editor with bold or italic characters. This is a deliberate design, and is typical among text editing programs used for writing code. When we use Microsoft Word, we are using a "what you see is what you get" editor -- we edit a document in a form resembling the final printed or presented document. The RStudio text editor is typical of text editors designed for coding in taking a different approach to formatting documents. When working with a plain text editor, we type unformatted plain text and code, and among the text we include instructions on how the final document should appear. We will discuss this further in Chapter XX, but as a quick example, if we wanted a word in bold, we would code it like `**this**`. In this example, the two asterix symbols will be interpreted by our computer when we convert our source document into a final version, such as a PDF, to produce a document with **this** word in bold. 

This method of creating documents is very common in disciplines such as mathematics and physics, where complex equations are written using code because for many people it is easier to write code to produce equations than use a mouse to click on menus and buttons to select the special characters needed for equations. LaTeX is widely used code-based document preparation system, with particular strengths in complex formatting needed by technical scientific documents. Although highly flexible, LaTeX is also complex and verbose, requiring a lot of typing to add the formatting code to your document. But don't worry, in this book we will use a much simpler document preparation system, known as markdown. We will discuss markdown in more detail in chapter XX, for now the main thing to know is that we use the text editor to write code and text. 

- The top right pane can have several tabs, depending on what you are doing. Most of the time you will see an 'Environment' tab and a 'History' tab. The Environment tab lists the objects that are currently available in your R session. For exampe, if you have executed code that reads an Excel spreadsheet into R and stores it as an R object, then you will see this object listed in the Environment tab. This tab is useful because you can get basic information at a glance about the size of objects that you make (e.g. how many rows and columns). This is convienent for quickly checking the output of your computations so you can see if your code is working as expected. The History tab shows the code you have previously executed in your R session. I rarely use this tab because I write code into the text editor and save the code to my computer, so I always have a copy of the code in the text editor. But if you are experimenting with some code in an expedient fashion, you can use the History tab to browse your previous commands to reuse and edit. You can also save the history of your R commands to a text file, but I don't recommend this as it is not an efficient method for keeping track of your work. A better strategy is to write code in the text editor, interspersed with text that explains what the code is doind, and save that document to your computer. We'll discuss this strategy more in chapter XX. 

- The lower right pane is another multi-tab pane where plots appear, the most important are the Plots tab and the Files tab. The Plots tab allows you to conveniently browse the plots that you produce. You can navigate back to previous plots, interact with plots by zooming and selecting, and you can export the plots to save them on your computer (in a variety of formats). 


- the lower left pane is the console where code is executed. 



Each pane can also have tabs that show additional views. You can see on the lower right pane there are several tabs, some of the others include a file manager, a package manager, and a help file viewer. The location and combination of panes and tabs are customisable. For example, I prefer to have to console on the upper right, and I often minimize some of the panes so I only see the text editor and the console. You can adjust these under Tools -> Global Options -> Pane Layout

## Key terms to understand (don't skip this bit!)

Now we've established the basic motivation for learning R to do archaeology, we should introduce some key terms and conventions that appear frequently in this book. Becoming familiar with these terms will help you with the basic tasks of finding your way around when starting to use R.

The `command line` refers to the location on your screen where you type, paste, or send code. At the left side of the command line is a `prompt`, which looks like this: `>` and has a blinking curser next to it. The prompt is found in the R `console`, which is the name of the window on your desktop where you enter code and receive output. `Code` refers to anything written in a programming language, from a single function to thousands of lines. Code often contains `comments`, which you can recognise by a `#` symbol at the start of the line. Code comments are to help you understand the purpose of the code. The `#` symbol tells R to everything to the right of that symbol, and skip to the next line of code. A `script` is a file that contains code, and usually R script file names ends with `.R` or `.r`. You can open these files in any program that edits text, for example Notepad on Windows (or Notepad++) or TextEdit on OSX (or Sublime Text).

A `function` refers to a group of code that carries out instructions to do useful work. For example, the function `mean()` computes the mean of a set of numbers. In this book you will always be able to recognise a function because they will always be followed by a pair of parentheses. A function is a handy way to organise code, because a single function can cause hundreds of lines of code to run to produce a result. Rather than running those hundreds of lines, one-by-one, over and over, we can simply type the function names that invokes them, and save ourself a lot of typing. Usually we want to save the output of a function so we can use in other functions, or for plotting. For example, we might want to compare the mean of the lengths of two assemblages of artefacts. To keep the results of function, we `assign` the output to an `object`. Here, we assign the output of the `mean()` function to an object that we arbitrarily call `x`, like so `x <- mean(c(4, 7, 12))`. This short piece of code computes the mean of 4, 7, and 12 (ie. (4 + 7 + 12)/3), and then assigns, or stores, the result in a object called `x` (we do not need to create `x` in advance). The `c` is a function to combine numbers into a set called a `vector`, which is a fundamental data object type in R. We can then use `x` later in our workflow for other tasks, rather than recomputing the mean repeatedly. 

There's lot more vocabularly to come, but these are the key terms that you need to know to make sense of the rest of this book. 

### Packages

Functions are at the heart of working with R, and are part of the reason for R's great versatility. They save a lot of time by minimizing copy-and-pasting and typing, so it's worth to invest some effort into learning how to write your own functions. Functions are typically organised into `packages`, which you can download to extend the usefulness of R. We will use packages extensively in this book, and briefly discuss how and why you might write your own packages. There are two common methods to install packages for R. For either method you need an internet connection, an R session (by opening RStudio), and to run a command at the command line.

The most common way to install R packages is to run the command, `install.packages()` at the R prompt. This will download the package from the repository at [cran.r-project.org](http://cran.r-project.org) and install them in your system library.

Try this yourself by opening R and running these commands:

```{r eval = FALSE, tidy = FALSE}
# install a single package
install.packages("devtools")
# install multiple packages at one time
install.packages(c("dplyr", "ggplot2", 
                   "knitr", "readr", "rmarkdown", 
                   "scales", "stringr", "tidyr"))
```

Most of the packages we will use in this book are stored on [cran.r-project.org](http://cran.r-project.org), but are other online repositories for R packages. For example, many R package authors use [www.github.com](http://www.github.com) to make their packages publicly available. 

You can install packages stored on github with the `install_github()` function in the `devtools` package (which we installed using the commands above). To use the `install_github()` function, pass it a character string with the form `"<github username>/<github repository name>"`. For example, we can install the package `ggbiplot` to plot the output of a Principle Components Analysis like this: 

```{r eval = FALSE}
devtools::install_github("vqv/ggbiplot")
```

When R installs a package, it downloads the package to your system `library`. You must use the `library()` function to make the contents of the package available to your current R session. It's good practice to have the `library()` functions among the first few lines of your code, so other users can quickly see what packages they will need to have to prepare to run your code. For example, to use the functions in the `dplyr` package, you would need to first run

```{r eval = FALSE}
library("dplyr")
```

You will need to rerun this `library()` command each time you open a new R session that uses functions from the `dplyr` package. 

## Getting help

Developing fluency in a language like German or Chinese takes time and has ups and downs. Learning a programming language like R is a similar process, and you should anticipate ups and downs as R becomes an increasingly central part of your workflow. Fortunately, there are a number of options for seeking help when you get stuck, or have a question. The simplest case is when you execute a line of code, only to get a cryptic error message in the console. A good first reponse is to copy the text of the error message to your clipboard, and paste it into a Google search box in your web browser. In most cases, the top search results will be from [Stack Overflow]( http://stackoverflow.com/) or one of the [R mailing lists](https://www.r-project.org/mail.html). Sometimes this will get you a quick solution. However, sometimes error messages are too generic, or too specific, and you can browse through many pages of search results without getting any useful ideas to solve your problem. When that happens, there are a few places online where you can give some more detail about your problem, and get more relevant responses.

Stack Overflow is a free question-and-answer website that is focused on computer programming. Participants receive points for asking clear questions, and for giving useful answers. This adds a competitive element to participating in the Q&A, and often when you ask a well-formed question, several answers will appear very quickly from participants eager to earn points. The R mailing lists are more traditional email-based fora, with archives at several places online. Highly skilled R programmers and R-using scientists from a variety of disciplines are active on both the R mailing lists and Stack Overflow. I prefer Stack Overflow because responses to my questions typically come quicker, and I find it easier to see when someone else's question has been answered, compared to browsing the email list archives. 

I find that in the course of writing my question to submit to Stack Overflow, the process of simplifying my code into a small, self-contained example leads me to discover the cause of my problem (very often it's a misplaced comma or bracket). Then I can answer my question before I need help from others. Similarly, I often find that many of my questions have already been asked and answered on Stack Overflow. The challenge in this case is to recognise how similar an existing question is to your current problem, and thus how useful the answers are to your specific issue. 

If you are sure that your problem is new and unique, and you want to submit a question, here is some general advice to help you get a useful answer quickly from the Stack Overflow and R mailing lists communities:

* Spend some time browsing previous posts to understand the community norms. Online communities have specific cultural values that are often strongly held. While some of these are spelled out in posting guides, many are also unwritten, and can only be learnt through mindful reading of previous correspondence. If you are familiar with the norms, you are more likely to have an efficient and satisfying interaction with the community.  

* Make sure you have the latest version of R and of the package (or packages) you are having problems with. It may be that your problem is the result of a recently fixed bug.

* Spend some time creating a reproducible example. This mean a simplified version of your problem that another person can copy and paste from their browser into their R console to reproduce the error that you see. This can be quite an art-form, but the basic ingredients for a good reproducible example are: 

1. The packages you are using    
2. A small data set. R comes with many example data sets built-in, if you run `data()` you can see a list, and these are very convenient to use for reproducible examples. If you want to include your own data, you can use `dput()` to generate R code that another person can copy and paste to recreate your data set.       
3. Code. Your code should be easy to read, with spaces between operators (+, -, *, etc.) and after commas, and conformant to a style guide, such as Hadley Wickham's [-@wickham2014advanced] [style guide in Advanced R](http://adv-r.had.co.nz/Style.html). Your code should includes lines of commentary, which begin with `#`, to help others understand your problem.    
4. A description of your R environment. The usual way to communicate your R environment (ie. your operating system type and version), is to include the output from `sessionInfo()` into your question.      

Don't worry if some of these terms are unfamiliar at the moment. The main thing to know at this point is that help is available, and that the quality of help you receive is proportional to the effort you spend seeking it. 



