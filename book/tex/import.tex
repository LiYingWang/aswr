\chapter{Data import}

\section{Overview}

You can't apply any of the tools you've applied so far to your own work,
unless you can get your own data into R. In this chapter, you'll learn
how to import:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Flat files (like csv) with readr.
\item
  Database queries with DBI.
\item
  Data from web APIs with httr.
\item
  Binary file formats (like excel or sas), with haven and readxl.
\end{itemize}

The common link between all these packages is they all aim to take your
data and turn it into a data frame in R, so you can tidy it and then
analyse it.

\section{Flat files}

There are many ways to read flat files into R. If you've be using R for
a while, you might be familiar with \texttt{read.csv()},
\texttt{read.fwf()} and friends. We're not going to use these base
functions. Instead we're going to use \texttt{read\_csv()},
\texttt{read\_fwf()}, and friends from the readr package. Because:

\begin{itemize}
\item
  These functions are typically much faster (\textasciitilde{}10x) than
  the base equivalents. Long run running jobs also have a progress bar,
  so you can see what's happening. (If you're looking for raw speed, try
  \texttt{data.table::fread()}, it's slightly less flexible than readr,
  but can be twice as fast.)
\item
  They have more flexible parsers: they can read in dates, times,
  currencies, percentages, and more.
\item
  They fail to do some annoying things like converting character vectors
  to factors, and munging the column headers to make sure they're valid
  R variable names.
\item
  They return objects with class \texttt{tbl\_df}. As you saw in the
  dplyr chapter, this provides a nicer printing method, so it's easier
  to work with large datasets.
\item
  They're designed to be as reproducible as possible - this means that
  you sometimes need to supply a few more arguments when using them the
  first time, but they'll definitely work on other peoples computers.
  The base R functions take a number of settings from system defaults,
  which means that code that works on your computer might not work on
  someone elses.
\end{itemize}

Make sure you have the readr package
(\texttt{install.packages("readr")}).

Most of readr's functions are concerned with turning flat files into
data frames:

\begin{itemize}
\item
  \texttt{read\_csv()} read comma delimited files, \texttt{read\_csv2()}
  reads semi-colon separated files (common in countries where \texttt{,}
  is used as the decimal place), \texttt{read\_tsv()} reads tab
  delimited files, and \texttt{read\_delim()} reads in files with a user
  supplied delimiter.
\item
  \texttt{read\_fwf()} reads fixed width files. You can specify fields
  either by their widths with \texttt{fwf\_widths()} or theirs position
  with \texttt{fwf\_positions()}. \texttt{read\_table()} reads a common
  variation of fixed width files where columns are separated by white
  space.
\item
  \texttt{read\_log()} reads Apache style logs. (But also check out
  \href{https://github.com/Ironholds/webreadr}{webreadr} which is built
  on top of \texttt{read\_log()}, but provides many more helpful tools.)
\end{itemize}

readr also provides a number of functions for reading files off disk
into simpler data structures:

\begin{itemize}
\item
  \texttt{read\_file()} reads an entire file into a single string.
\item
  \texttt{read\_lines()} reads a file into a character vector with one
  element per line.
\end{itemize}

These might be useful for other programming tasks.

As well as reading data frame disk, readr also provides tools for
working with data frames and character vectors in R:

\begin{itemize}
\item
  \texttt{type\_convert()} applies the same parsing heuristics to the
  character columns in a data frame. You can override its choices using
  \texttt{col\_types}.
\item
  \texttt{parse\_datetime()}, \texttt{parse\_factor()},
  \texttt{parse\_integer()}, etc. Corresponding to each
  \texttt{col\_XYZ()} function is a \texttt{parse\_XYZ()} function that
  takes a character vector and returns a parsed vector. We'll use these
  in examples so you can see how a single piece works at a time.
\end{itemize}

For the rest of this chapter we'll focus on \texttt{read\_csv()}. If you
understand how to use this function, it will be straightforward to your
knowledge to all the other functions in readr.

\subsection{Basics}

The first two arguments of \texttt{read\_csv()} are:

\begin{itemize}
\item
  \texttt{file}: path (or URL) to the file you want to load. Readr can
  automatically decompress files ending in \texttt{.zip}, \texttt{.gz},
  \texttt{.bz2}, and \texttt{.xz}. This can also be a literal csv file,
  which is useful for experimenting and creating reproducible examples.
\item
  \texttt{col\_names}: column names. There are three options:

  \begin{itemize}
  \item
    \texttt{TRUE} (the default), which reads column names from the first
    row of the file
  \item
    \texttt{FALSE} number columns sequentially from \texttt{X1} to
    \texttt{Xn}.
  \item
    A character vector, used as column names. If these don't match up
    with the columns in the data, you'll get a warning message.
  \end{itemize}
\end{itemize}

EXAMPLE

\subsection{Column types}

Readr uses a heuristic to figure out the types of your columns: it reads
the first 1000 rows. This is fast, and fairly robust. If readr detects
the wrong type of data, you'll get warning messages:

EXAMPLE

You can fix these by overriding readr's guesses with the
\texttt{col\_type} argument.

(Note that if you have a very large file, you might want to set
\texttt{n\_max} to 10,000 or 100,000. That will speed up iteration while
you're finding common problems)

\begin{itemize}
\item
  \texttt{col\_integer()} and \texttt{col\_double()} specify integer and
  doubles. \texttt{col\_number()} is a more flexible parsed for numbers
  embedded in other strings. It will look for the first number in a
  string, ignoring non-numeric prefixes and suffixes. It will also
  ignoring the grouping mark specified by the locale (see below for more
  details).
\item
  \texttt{col\_logical()} parses TRUE, T, FALSE and F into a logical
  vector.
\item
  \texttt{col\_character()} leaves strings as is. \texttt{col\_factor()}
  allows you to load data directly into a factor if you know what the
  levels are.
\item
  \texttt{col\_skip()} completely ignores a column.
\item
  \texttt{col\_date()}, \texttt{col\_datetime()} and
  \texttt{col\_time()} parse into dates, date times, and times as
  described below.
\end{itemize}

Parsing occurs after leading and trailing whitespace has been removed
(if not overridden with \texttt{trim\_ws\ =\ FALSE}) and missing values
listed in \texttt{na} have been removed.

\subsubsection{Datetimes}

Readr provides three options depending on where you want a date (the
number of days since 1970-01-01), a date time (the number of seconds
since midnight 1970-01-01), or a time (i.e.~the number of seconds since
midnight). The defaults read:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Date times: an \href{https://en.wikipedia.org/wiki/ISO_8601}{ISO8601}
  date time.
\item
  Date: a year, optional separator, month, optional separator, day.
\item
  Time: an hour, optional colon, hour, optional colon, minute, optional
  colon, optional seconds, optional am/pm.
\end{itemize}
